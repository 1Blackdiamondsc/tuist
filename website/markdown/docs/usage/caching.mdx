---
name: Caching dependencies
excerpt: 'Learn how to use caching of targets to speed up build times in your projects.'
---

# Caching dependencies

Tuist has support for caching a pre-compiled version of your project targets locally and remotely.
When targets are cached, developers can generate projects where the targets they don't plan to work on are replaced with their pre-compiled version.
In modular apps, this feature yields significant improvements in build times.

Unlike [Bazel](https://bazel.build/) or [Buck](https://buck.build/) that replace Xcode's build system to cache individual build steps,
we do caching at the module level. That means developers can use Xcode and its build system and don't have to develop tooling around alternative build systems to integrate them with developers tooling.

![An image that shows how the caching feature works](./cache.png)

## Warming the cache

Warming the cache is the process of building, hashing, and storing cacheable targets in the cache.
We recommend setting up a continuous integration pipeline that runs on every master commit and executes the following command:

```
tuist cache warm
```

## Focusing on a project

Once the cache has been warmed with the pre-compiled targets,
we can tell Tuist that we want to focus on a particular project and get the dependencies from the cache.
All we need to do is run the following command:

```
tuist focus --cache
```

## Debugging

### Print target hashes

Targets are uniquely identified in the cache. The identifier (hash) is obtained by hashing the attributes of the target, its project,
the environment (e.g. Tuist version) and the hashes of its dependencies.
To facilitate debugging, Tuist exposes a command that prints the hash of every target of the dependency tree:

```
tuist cache print-hashes
```

## Best practices

This section contains some best practices that we recommend everyone to read thoroughly:

- **Don't leak interfaces or transitive dependencies:** Accessing the interface of a transitive dependency is creating an implicit dependency with it. For example, if App depends on `Framework`, and `Framework` depends on `Package`, `App` shouldn't consume interfaces from `Package`, unless it's defined as a dependency of the app explicitly. Otherwise `App` will fail to compile because it won't find the interface of `Package`.
- **Don't introduce side effects through script build phases:** A build phase might introduce side effects that Tuist is not aware of, and as a result, the cache might not get invalidated when it should. If you have the need for a custom script build phase, open an issue on the repository with your use case so that we can evaluate your need and provide a declarative interface for it.

## Limitations

- **Caching not supported for libraries with resources:** Even though defining resources in libraries is [supported](/docs/usage/resources/), we don't support caching them yet.
